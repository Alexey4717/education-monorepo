# 1. Общие данные о Next.js

Это надстройка над React. Но react - это чистый веб-фреймворк.
Для чего нужен next:

- SEO
- Оптимизация
- секьюрность

Но нужно думать о некоторых моментах (например что компонент грузится 2 раза на сервере и на клиенте)

- автоматическая оптимизация картинок, шрифтов, скриптов (аналитика)
- глобальная интеграция с серверными компонентами и AppRouter, можно подгружать Suspence данные отдельно от основного
  дерева
- Подгрузка данных на сервере (нет дополнительного ожидания fetch запроса на сервер). Можно получать данные через
  статику, клиент получает сперва данные, потом остальное.
- серверные экшена (запуск каких=то функций только на сервере)
- поддержка middleware (правила которые будут работать до загрузки страницы). Интернализация, авторизация

В next v15

- Поддержка react19

## 2. В 14 нексте появилась возможность писать директивы сверху страницы "use-client"/"use-server"

по дефолту все серверные, если не указывать

### use-client

Это не полность. клиентский компонент, просто некст будет собирать его на сервере как клиентский компонент и относиться
к нему как к клиентскому.
Это легко проверить, написав window в компоненте. Выскочит 1 ошибка, т.к. сначала компонент собирается на сервере. 2
сборка уде на клиенте, там ошибки не будет.

Но тем-не-мение можно запустить useServer хук, который на сервере запускается.

Если сделать проверку на наличие window, то на сервере ошибки не будет, но на клиенте возникнет ошибка гидратации, т.к.
не сходятся данные (на сервере были одни по условию, на клиенте другие).
Данные должны сходиться, чтобы успешно прошла гидратация (наложение того, что пришло с сервера, на клиент).
Решения проблемы тут: https://nextjs.org/docs/messages/react-hydration-error

В useEffect все происходит точно на клиенте.
Лучше все разруливать через состояние, если такая ошибка. Отключать на сервере компонент (2 шаг) лучше не стоит, хуже
оптимизация.
Только если доступ к localStorage внутри тела компонента или какая-то библиотека шалит.
sypressHydrationWarning (отключать предупреждение об этом) стоит для дат (меняется) или тем (т.е. не доступно на
сервере).
Если используем хуки запросов например (useQuery, useMutation), то обязательно помечать компоненты как use-client.

use-client можно указать родителю и оно будет успошно и для всех его детей.
Если оборачиваем все приложение провайдером (например ReduxProvider) и у него указываем use-client, это не значит что
все приложение стало с use-client.
Можно внутри объявлять серверные компоненты use-server.
Когда в ран-тайме меняем импорты, директивы, нужно обязательно обновлять страницы, т.к. некст в моменте все кеширует и
за счет быстрой перезагрузки стр (hot reload) может показаться что огибки нет.
Но нужно полностью обновить страницу самому, особенно перед пушем, чтоб удостовериться что сборка рабочая.

## 3. Виды запросов.

В реакте данные подгружаются на стороне клиента (в useEffect или useQuery), на нексте загрузка данных с сервера.

### SSR

Загрузка данных на стороне сервера без кеширования, всегда свежие данные в момент запроса и загрузки страницы.
Минус - это производительность. Нужно использовать если нужны всегда прям свежие данные по апи.
В серверных компонентах переводим их в асинхронные функции и прям в теле компонента делаем запросы с await данных.
При загрузке страница пометится как DynamicPage и оптимизация будет страдать.
Лучше когда уже есть данные и клиент их постоянно получает (закешированы).
Можно вообще всю бд записать в серверный компонент, но мы так делать не будем. У нас некст для фронта.
т.к. проект становится очень большим если мешать его с бэком, нужно разделять ответственность.

в use-client компоненте по классике запрос в useEffect.

### SSG

То же самое что SSR, что отличия в оптимизации. Есть кеширование.
Минус - не всегда свежие данные. Данные собираются при сборке проекта, записываются и используются в приложении.
Чтобы их заново обновить, нужно было писать команды и обновлять проект на сервере.
Нет адыкватной работы с авторизацией, нельзя получить доступ к актуальным данным.
Поэтому SSG мало кто предпочитает.

### ISR

Что-то среднее между SSR и SSG. Та же самая статика как и в SSG, но при этом можно сделать чтоб данные при определенных
условиях динамически обновлялись.
Один пользователь запросил данные, они созранились в кеш, потом другой пользователь запрашивает данные уже из кеша.
Можно разные данные обновлять раз в какой-то интервал.

## 4. Ничего интересного, разворачивание проекта

## 5. Начальная настройка

Шрифты в нексте импортыруются из next/font/google

## 6. Архитектура, tsconfig, prettier

Добавили @trivago/prettier-plugin-sort-imports для автосортировки импортов

Архитектура:

```text
providers - обертки приложения

```

## 7. layout.

Раньше роутинг был в pages, сейчас в app.
Чтоб внутри src/app работал роутинг, нужно добавлять page.tsx (для вложенных роутов - вложенные папки).
Внутри page.tsx должны быть дефолтные импорты, чтоб работал роутинг.

Если хотим, чтоб папка не учавствовала в роутинге, то её название оборачиваем в скобки (profile).
Если там внутри будет (profile)/test/page.tsx, то роут будет доступен по baseApi/test (а не baseApi/profile/test).
[] в названии папки - для динамических параметров в роуте.

Все названия файлов представлены в:
https://nextjs.org/docs/app/api-reference/file-conventions

Например есть layout.ts - глобальная обертка (действует на все папки/pages внутри)

Можно сделать так:

```text
app
    layout.tsx
    (profile)
        layout.tsx 
        // лэйаут для профиля, но действует так же глобально на все приложение,
        // т.к. папка в скобках (все равно что вынесен в app, но сгруппирован в отдельной папке)
```

- loading - если используется suspense (редко используется)
- not-found - 404 стр
- error - кастомная страница, если на роуте ошибка
- global-error - для перехвата глобальной ошибки (в нексте)
- route - для создания api на стороне сервере (редко используется, если только для фронта юзать некст, но можно для
  парсинга). Так же обработка NextRequest, NextResponse, возвращение NextResponse.json со статусами (похоже как в
  express.js).
- templates - шаблоны, принимают пропсы. Редко используется.
- default - для рендера фолбека в течение параллельных роутов (можно на 1 странице грузить 2 роута). Тоже редко
  используется, часто всплывают с ними баги.

Т.е. как в реакте нет таких оберток в исходниках:

```tsx
<Layout>
    <ErrorBoundary>
        <Template>
            <App />
        </Template>
    </ErrorBoundary>
</Layout>
```

Так код компилируется, а в исходниках используются file-conventions

В page или layout можно указать export const metadata, для СЕО, там указывается title, description.

## 8. Навигация и сайдбар.

Добавили либу lucide-react для иконок

Link используются из 'next/link', чтобы работала навигация внутри некста. Там указывается href (а не to как в
react-router).

## 9. Стили для лжйаута и сайдбара

Скачали пакет clsx для функции нескольких классов, передаваемых в элементы.

У tailwindcss есть готовые классы, которые можно навешивать на элементы без импортов.
Типа w-60 (ширина 60px).
