# 1. Общие данные о Next.js

Это надстройка над React. Но react - это чистый веб-фреймворк.
Для чего нужен next:
- SEO
- Оптимизация
- секьюрность

Но нужно думать о некоторых моментах (например что компонент грузится 2 раза на сервере и на клиенте)

- автоматическая оптимизация картинок, шрифтов, скриптов (аналитика)
- глобальная интеграция с серверными компонентами и AppRouter, можно подгружать Suspence данные отдельно от основного дерева
- Подгрузка данных на сервере (нет дополнительного ожидания fetch запроса на сервер). Можно получать данные через статику, клиент получает сперва данные, потом остальное.
- серверные экшена (запуск каких=то функций только на сервере)
- поддержка middleware (правила которые будут работать до загрузки страницы). Интернализация, авторизация

В next v15
- Поддержка react19

## 2. В 14 нексте появилась возможность писать директивы сверху страницы "use-client"/"use-server"

по дефолту все серверные, если не указывать

### use-client

Это не полность. клиентский компонент, просто некст будет собирать его на сервере как клиентский компонент и относиться к нему как к клиентскому.
Это легко проверить, написав window в компоненте. Выскочит 1 ошибка, т.к. сначала компонент собирается на сервере. 2 сборка уде на клиенте, там ошибки не будет.

Но тем-не-мение можно запустить useServer хук, который на сервере запускается.

Если сделать проверку на наличие window, то на сервере ошибки не будет, но на клиенте возникнет ошибка гидратации, т.к. не сходятся данные (на сервере были одни по условию, на клиенте другие).
Данные должны сходиться, чтобы успешно прошла гидратация (наложение того, что пришло с сервера, на клиент).
Решения проблемы тут: https://nextjs.org/docs/messages/react-hydration-error

В useEffect все происходит точно на клиенте.
Лучше все разруливать через состояние, если такая ошибка. Отключать на сервере компонент (2 шаг) лучше не стоит, хуже оптимизация.
Только если доступ к localStorage внутри тела компонента или какая-то библиотека шалит.
sypressHydrationWarning (отключать предупреждение об этом) стоит для дат (меняется) или тем (т.е. не доступно на сервере).
Если используем хуки запросов например (useQuery, useMutation), то обязательно помечать компоненты как use-client.

use-client можно указать родителю и оно будет успошно и для всех его детей.
Если оборачиваем все приложение провайдером (например ReduxProvider) и у него указываем use-client, это не значит что все приложение стало с use-client.
Можно внутри объявлять серверные компоненты use-server.
Когда в ран-тайме меняем импорты, директивы, нужно обязательно обновлять страницы, т.к. некст в моменте все кеширует и за счет быстрой перезагрузки стр (hot reload) может показаться что огибки нет.
Но нужно полностью обновить страницу самому, особенно перед пушем, чтоб удостовериться что сборка рабочая.

## 3. Виды запросов.
В реакте данные подгружаются на стороне клиента (в useEffect или useQuery), на нексте загрузка данных с сервера.

### SSR

Загрузка данных на стороне сервера без кеширования, всегда свежие данные в момент запроса и загрузки страницы.
Минус - это производительность. Нужно использовать если нужны всегда прям свежие данные по апи.
В серверных компонентах переводим их в асинхронные функции и прям в теле компонента делаем запросы с await данных.
При загрузке страница пометится как DynamicPage и оптимизация будет страдать.
Лучше когда уже есть данные и клиент их постоянно получает (закешированы).
Можно вообще всю бд записать в серверный компонент, но мы так делать не будем. У нас некст для фронта.
т.к. проект становится очень большим если мешать его с бэком, нужно разделять ответственность.

в use-client компоненте по классике запрос в useEffect.

### SSG

То же самое что SSR, что отличия в оптимизации. Есть кеширование.
Минус - не всегда свежие данные. Данные собираются при сборке проекта, записываются и используются в приложении.
Чтобы их заново обновить, нужно было писать команды и обновлять проект на сервере.
Нет адыкватной работы с авторизацией, нельзя получить доступ к актуальным данным.
Поэтому SSG мало кто предпочитает.

### ISR

Что-то среднее между SSR и SSG. Та же самая статика как и в SSG, но при этом можно сделать чтоб данные при определенных условиях динамически обновлялись.
Один пользователь запросил данные, они созранились в кеш, потом другой пользователь запрашивает данные уже из кеша.
Можно разные данные обновлять раз в какой-то интервал.

## 4. Ничего интересного, разворачивание проекта

## 5. Начальная настройка

Шрифты в нексте импортыруются из next/font/google