# 1. Общие данные о Next.js

Это надстройка над React. Но react - это чистый веб-фреймворк.
Для чего нужен next:

- SEO
- Оптимизация
- секьюрность

Но нужно думать о некоторых моментах (например что компонент грузится 2 раза на сервере и на клиенте)

- автоматическая оптимизация картинок, шрифтов, скриптов (аналитика)
- глобальная интеграция с серверными компонентами и AppRouter, можно подгружать Suspence данные отдельно от основного
  дерева
- Подгрузка данных на сервере (нет дополнительного ожидания fetch запроса на сервер). Можно получать данные через
  статику, клиент получает сперва данные, потом остальное.
- серверные экшена (запуск каких=то функций только на сервере)
- поддержка middleware (правила которые будут работать до загрузки страницы). Интернализация, авторизация

В next v15

- Поддержка react19

## 2. В 14 нексте появилась возможность писать директивы сверху страницы "use-client"/"use-server"

по дефолту все серверные, если не указывать

### use-client

Это не полность. клиентский компонент, просто некст будет собирать его на сервере как клиентский компонент и относиться
к нему как к клиентскому.
Это легко проверить, написав window в компоненте. Выскочит 1 ошибка, т.к. сначала компонент собирается на сервере. 2
сборка уде на клиенте, там ошибки не будет.

Но тем-не-мение можно запустить useServer хук, который на сервере запускается.

Если сделать проверку на наличие window, то на сервере ошибки не будет, но на клиенте возникнет ошибка гидратации, т.к.
не сходятся данные (на сервере были одни по условию, на клиенте другие).
Данные должны сходиться, чтобы успешно прошла гидратация (наложение того, что пришло с сервера, на клиент).
Решения проблемы тут: https://nextjs.org/docs/messages/react-hydration-error

В useEffect все происходит точно на клиенте.
Лучше все разруливать через состояние, если такая ошибка. Отключать на сервере компонент (2 шаг) лучше не стоит, хуже
оптимизация.
Только если доступ к localStorage внутри тела компонента или какая-то библиотека шалит.
sypressHydrationWarning (отключать предупреждение об этом) стоит для дат (меняется) или тем (т.е. не доступно на
сервере).
Если используем хуки запросов например (useQuery, useMutation), то обязательно помечать компоненты как use-client.

use-client можно указать родителю и оно будет успошно и для всех его детей.
Если оборачиваем все приложение провайдером (например ReduxProvider) и у него указываем use-client, это не значит что
все приложение стало с use-client.
Можно внутри объявлять серверные компоненты use-server.
Когда в ран-тайме меняем импорты, директивы, нужно обязательно обновлять страницы, т.к. некст в моменте все кеширует и
за счет быстрой перезагрузки стр (hot reload) может показаться что огибки нет.
Но нужно полностью обновить страницу самому, особенно перед пушем, чтоб удостовериться что сборка рабочая.

## 3. Виды запросов.

В реакте данные подгружаются на стороне клиента (в useEffect или useQuery), на нексте загрузка данных с сервера.

### SSR

Загрузка данных на стороне сервера без кеширования, всегда свежие данные в момент запроса и загрузки страницы.
Минус - это производительность. Нужно использовать если нужны всегда прям свежие данные по апи.
В серверных компонентах переводим их в асинхронные функции и прям в теле компонента делаем запросы с await данных.
При загрузке страница пометится как DynamicPage и оптимизация будет страдать.
Лучше когда уже есть данные и клиент их постоянно получает (закешированы).
Можно вообще всю бд записать в серверный компонент, но мы так делать не будем. У нас некст для фронта.
т.к. проект становится очень большим если мешать его с бэком, нужно разделять ответственность.

в use-client компоненте по классике запрос в useEffect.

### SSG

То же самое что SSR, что отличия в оптимизации. Есть кеширование.
Минус - не всегда свежие данные. Данные собираются при сборке проекта, записываются и используются в приложении.
Чтобы их заново обновить, нужно было писать команды и обновлять проект на сервере.
Нет адыкватной работы с авторизацией, нельзя получить доступ к актуальным данным.
Поэтому SSG мало кто предпочитает.

### ISR

Что-то среднее между SSR и SSG. Та же самая статика как и в SSG, но при этом можно сделать чтоб данные при определенных
условиях динамически обновлялись.
Один пользователь запросил данные, они созранились в кеш, потом другой пользователь запрашивает данные уже из кеша.
Можно разные данные обновлять раз в какой-то интервал.

## 4. Ничего интересного, разворачивание проекта

## 5. Начальная настройка

Шрифты в нексте импортыруются из next/font/google

## 6. Архитектура, tsconfig, prettier

Добавили @trivago/prettier-plugin-sort-imports для автосортировки импортов

Архитектура:

```text
providers - обертки приложения

```

## 7. layout.

Раньше роутинг был в pages, сейчас в app.
Чтоб внутри src/app работал роутинг, нужно добавлять page.tsx (для вложенных роутов - вложенные папки).
Внутри page.tsx должны быть дефолтные импорты, чтоб работал роутинг.

Если хотим, чтоб папка не учавствовала в роутинге, то её название оборачиваем в скобки (profile).
Если там внутри будет (profile)/test/page.tsx, то роут будет доступен по baseApi/test (а не baseApi/profile/test).
[] в названии папки - для динамических параметров в роуте.

Все названия файлов представлены в:
https://nextjs.org/docs/app/api-reference/file-conventions

Например есть layout.ts - глобальная обертка (действует на все папки/pages внутри)

Можно сделать так:

```text
app
    layout.tsx
    (profile)
        layout.tsx 
        // лэйаут для профиля, но действует так же глобально на все приложение,
        // т.к. папка в скобках (все равно что вынесен в app, но сгруппирован в отдельной папке)
```

- loading - если используется suspense (редко используется)
- not-found - 404 стр
- error - кастомная страница, если на роуте ошибка
- global-error - для перехвата глобальной ошибки (в нексте)
- route - для создания api на стороне сервере (редко используется, если только для фронта юзать некст, но можно для
  парсинга). Так же обработка NextRequest, NextResponse, возвращение NextResponse.json со статусами (похоже как в
  express.js).
- templates - шаблоны, принимают пропсы. Редко используется.
- default - для рендера фолбека в течение параллельных роутов (можно на 1 странице грузить 2 роута). Тоже редко
  используется, часто всплывают с ними баги.

Т.е. как в реакте нет таких оберток в исходниках:

```tsx
<Layout>
    <ErrorBoundary>
        <Template>
            <App />
        </Template>
    </ErrorBoundary>
</Layout>
```

Так код компилируется, а в исходниках используются file-conventions

### CEO:

В page или layout можно указать export const metadata, для СЕО, там указывается title, description и много чего еще
(можно провалить в тип и посмотреть).
verification - можно подтвердить гугл/яндекс/любой другой токен
alternates.canonical - ссылки
openGraph - можно выносить в отдельную константу
Охвачены почти все кейсы SEO, но если что-то не охвачено, можно использовать other
Можно метаданные общие выносить в Layout и она распространяется на другие вложенные страницы. Но почему-то openGraph
не всегда распространялся на все страницы и приходилось руками прокидывать в страницы константу туда.

Можно вынести в лэйаут общее название title, а на разных страницах добавлять приставки к ним

```tsx
export const metadata: Metadata = {
    title: {
        absolute: 'Mediahub' // статичное/неизменное название
        template: `%s | Mediahub` // %s - это переменная из шаблона
    },
    description: 'Hub for sharing video/blogs/posts',
};
```

Только в дочерних страницах (если страница в той же папке что и layout, то на неё не распространяется):

```tsx
export const metadata: Metadata = {
    title: 'Trending',
    description: 'Trending desc',
    alternates: {
        canonical: PAGE.TRENDING,
    },
    openGraph: {
        type: 'website',
        url: PAGE.TRENDING,
        title: 'Trending',
    },
};
```

Можно создать директорию app/(public) с публичными страницами

## 8. Навигация и сайдбар.

Добавили либу lucide-react для иконок

Link используются из 'next/link', чтобы работала навигация внутри некста. Там указывается href (а не to как в
react-router).

## 9. Стили для лжйаута и сайдбара

Скачали пакет clsx для функции нескольких классов, передаваемых в элементы.

У tailwindcss есть готовые классы, которые можно навешивать на элементы без импортов.
Типа w-60 (ширина 60px).

## 11. Активный пункт сайдбара

Установили либу path-to-regexp, которая позволяет более гибко настраивать проверку текущего пути.
использовали usePathname из next/navigation для определения текущего пути.
Но с ним будет не всегда корректная проверка (=== или includes, или еще что-то, т.к. модет быть в конце слеш и т.п.,
много кейсов может быть).
С такой проверкой isActive={!!match(menuItem.link)(pathname)} будет более корректная проверка.

## 12. TanstackQuery, axios, карточка video

Добавили пакеты axios @tanstack/react-query dayjs

Используем компонент Image from 'next/image', который автоматически сжимает (оптимизированно рендерит изображение).

На главной странице мы не будет использовать tanStack-query, потому что тут статика больше подойдёт, чем клиентский
рендеринг.
Т.к. страница не требует авторизации и доступна для всех и нужно чтоб она быстрее подгружалась.
Если будут данные, которые требуют авторизации на главной странице, то их можно загрузить через tanStack-query в
дочерних компонентах.

## 13.

Сделали Провайдер для TanStackProvider для передачи queryClient.

Если в компоненте хуки, обязательно ввызывать use client.

## 14. Практика за SSR, SSG, ISR, запросы

Для запросов не требующих авторизации (videos) сделали загрузку на стороне ервера, убрали use client, вынесли запрос в
отдельную async функцию.
Неважно чем запрашивать данные (fetch, axios), некст будет кешировать данные.
Часто используют fetch. Мы будем использовать axios.

Чтобы это была и статика и ревалидация, над серверным компонентом объявляем export const revalidate = 100;
Так же эту опцию можно укзать в fetch (т.к. он расширяется в next, это не просто fetch который на клиенте в браузере).
Так каждые 100 секунд данные будут ревалидироваться. Т.е. данные записались 1 раз в кеш и потом обновляются.
Первый запрос к странице/route вызывает генерацию данных (SSR или SSG) → результат кешируется.
Все последующие запросы в течение 100 секунд получают кешированную версию.

По истечении 100 секунд при следующем запросе:

- Next.js перегенерирует данные в фоне (background revalidation).
- А пользователю всё ещё возвращает старую кеш-версию (ISR: Incremental Static Regeneration).
- При следующем запросе будет отдана уже новая версия данных.

Это работает если:

- Компонент серверный (не use client).
- Используется fetch или getStaticProps/getServerSideProps с ISR.
- Или используется fetch(..., { next: { revalidate: 100 } }).

Если сделать билд next приложения, то в консоли будет написано, что главная страница является статикой, т.к. дописали
туда revalidate.

В 14 нексте по-умолчанию при запросах была опция cache: force-cache, по умолчанию был кеш включен при отправке запросов.
В 15 нексте по-умолчанию cache: no-store (SSR)

Чтобы предотвратить предварительную отрисовку страницы объявляется export const dynamic = 'force-dynamic';
С такой опцией, после билда будет написано f(dynamic) - server rendering on demand
Так должно выглядеть если запущен SSR.

Если укажем export const dynamic = 'force-static';
То при билде будет написано o(Static) Prerendered as static content
Так должно выглядеть если запущен ISR (с ревалидацией) или SSG (без ревалидации).
Если запустить такой билд, загрузка будет очень быстрой, даже после перезагрузки страницы с обновлением кеша.
При смене роутов так же все оч быстро рендерится.

С use client загрузка визуально будет медленнее, т.к. происходят запросы данных на клиенте с сервера.
Можно перенести авторизацию на некст и делать все запросы на сервере.
Но это не очень хорошее решение, т.к. нужно разделять логику на сервере и фронте.
Для данных с авторизацией нужна динамика, для разных пользователей разный контент.
Если все на нексте делать, то будет хромать масштабирование, оптимизация, скорость в целом.
Нужно будет постоянно повышать производительность хостов сервера для некста и т.д.

## 15. ui компоненты хедера.

Установили пакет tailwind-merge для удобного совмещения классов, избегая конфликтов.
